import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Stack;

public class Expression {

	private ExpressionNode myRoot;
	private boolean IAmDebugging = true;

	// constructors
	public Expression() { // does it need a string argument?
		myRoot = null;
	}

	public Expression(String s) {
		(ExpressionNode);
		myRoot = s;
	}

	public Expression(ExpressionNode t) {
		myRoot = t;
	}

	// sample trees to test things
	public void fillSampleTree1() {
		if (IAmDebugging) {
			myRoot = new ExpressionNode("a", new ExpressionNode("b"),
					new ExpressionNode("c"));
		}
	}

	public void fillSampleTree2() {
		if (IAmDebugging) {
			myRoot = new ExpressionNode("a", new ExpressionNode("b",
					new ExpressionNode("d", new ExpressionNode("e"),
							new ExpressionNode("f")), null),
					new ExpressionNode("c"));
		}
	}

	public void fillSampleTree3() {
		if (IAmDebugging) {
			myRoot = new ExpressionNode("a", new ExpressionNode("b"),
					new ExpressionNode("c", new ExpressionNode("d",
							new ExpressionNode("e"), new ExpressionNode("f")),
							null));
		}
	}

	public void fillSampleTree4() {
		if (IAmDebugging) {
			myRoot = new ExpressionNode("a", new ExpressionNode("b",
					new ExpressionNode("d"), new ExpressionNode("e")),
					new ExpressionNode("c", new ExpressionNode("f"),
							new ExpressionNode("g")));
		}
	}

	// method to draw the tree
	public void print() {
		if (myRoot != null) {
			printHelper(myRoot, 0);
		}
	}

	private static final String indent1 = "    ";

	private static void printHelper(ExpressionNode root, int indent) {
		if (root.myRight != null) {
			printHelper(root.myRight, indent + 1);
		}
		println(root.myItem, indent);
		if (root.myLeft != null) {
			printHelper(root.myLeft, indent + 1);
		}
	}

	private static void println(Object obj, int indent) {
		for (int k = 0; k < indent; k++) {
			System.out.print(indent1);
		}
		System.out.println(obj);
	}

	// the node object
	private static class ExpressionNode {

		public Object myItem;
		public ExpressionNode myLeft;
		public ExpressionNode myRight;

		public ExpressionNode(Object obj) {
			myItem = obj;
			myLeft = myRight = null;
		}

		public ExpressionNode(Object obj, ExpressionNode left,
				ExpressionNode right) {
			myItem = obj;
			myLeft = left;
			myRight = right;
		}
	}

	public static Expression exprTree(String s) {

		Expression result = new Expression();
		result.myRoot = result.exprTreeHelper(s);
		// also need to check for illegal input
		return result;
	}

	private ExpressionNode exprTreeHelper(String expr) {
		boolean foundOperator = false;
		String opnd1;
		String opnd2;
		String op;
		if ((expr == null) || (expr.equalsIgnoreCase(""))) {
			return null;
		}
		if (expr.charAt(0) != '(') {
			if (expr.charAt(0) == '~') {
				try {
					expr.charAt(1);
				} catch (StringIndexOutOfBoundsException e) {
					throw new IllegalArgumentException(
							"Invalid input: ~ must take an argument");
				}

				op = "~";
				opnd1 = expr.substring(1, expr.length());
				return new ExpressionNode("~", exprTreeHelper(opnd1), null);
			}
			return new ExpressionNode(expr);
			// assume every sub-expression is in parentheses
			// so the only one without parentheses is a single variable
		} else {
			// expr is a parenthesized expression.
			int nesting = 0;// probably should be 0
			int opPos = 0;
			boolean isImplication = false; // If it is '=>' symbol, this boolean
											// value is set to true.

			for (int k = 1; k < expr.length() - 1; k++) {
				// this skips the enclosing parentheses, so it sees main
				// operation at nesting=0
				// find the main operator (an occurrence of + or * not nested in
				// parentheses
				if (expr.charAt(k) == '(') {
					nesting++;
				}
				if (expr.charAt(k) == ')') {
					nesting--;
				}
				if ((nesting == 0)
						&& ((expr.charAt(k) == '&') || (expr.charAt(k) == '|'))) {
					opPos = k;
				} else if ((nesting == 0) && (expr.charAt(k) == '=')
						&& (expr.charAt(k + 1) == '>')) {
					opPos = k;
					k++; // we add additional 1 since we processed two
							// characters.
					isImplication = true;
				} // else if ((nesting == 0) && (expr.charAt(k) == '~')) {
					// opPos = k;
					// isNot = true;
				// }
			}

			try {
				if (isImplication) {
					op = expr.substring(opPos, opPos + 2);
					opnd1 = expr.substring(1, opPos);
					opnd2 = expr.substring(opPos + 2, expr.length() - 1);
				} else {
					op = expr.substring(opPos, opPos + 1);
					opnd1 = expr.substring(1, opPos);
					opnd2 = expr.substring(opPos + 1, expr.length() - 1);
				}

			} catch (StringIndexOutOfBoundsException e) {
				throw new IllegalArgumentException(
						"Invalid input: check the parentheses");
			}
			System.out.println("expression = " + expr);
			System.out.println("operand 1  = " + opnd1);
			System.out.println("operator   = " + op);
			System.out.println("operand 2  = " + opnd2);
			System.out.println();
			// construct the two subtrees.
			return new ExpressionNode(op, exprTreeHelper(opnd1),
					exprTreeHelper(opnd2));

		}
	}

	public class ExprIterator implements Iterator<ExpressionNode> {
		// ExpressionNodes in the family are enumerated in preorder,
		// with children enumerated oldest first.
		// This exprIterator is Depth-first.

		private Stack<ExpressionNode> fringe = new Stack<ExpressionNode>();

		public ExprIterator() {
			if (myRoot != null) {
				fringe.push(myRoot);
			}
		}

		public boolean hasNext() {
			return !fringe.empty(); // check if there is something in fringe.
		}

		public ExpressionNode next() {
			if (!hasNext()) {
				throw new NoSuchElementException("tree ran out of elements");
			}

			// Be careful! index is one less than the size.
			ExpressionNode currentExpr = fringe.pop();
			if (currentExpr.myRight != null) {
				fringe.push(currentExpr.myRight);
				fringe.push(currentExpr.myLeft);
			}
			return currentExpr;
		}

		public void remove() {
			// not used
		}
	} // end of depth first ExprIterator nested class

}
