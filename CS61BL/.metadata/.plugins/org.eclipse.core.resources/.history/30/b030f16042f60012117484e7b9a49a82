import java.util.HashSet;

public class JugSolver {
	private int desiredAmt;
	private int capacity[];
	private HashSet<JugContents> hs = new HashSet<JugContents>();

	public JugSolver(int jug0size, int jug1size, int jug2size, int desired) {
		capacity = new int[3];
		capacity[0] = jug0size;
		capacity[1] = jug1size;
		capacity[2] = jug2size;
		desiredAmt = desired;
	}

	public int hashCode() {
		int base = 1;
		int hash = 0;
		for (int c = 0; c < 3; c++) {
			hash = hash + jugs[c] * base;
			base = base * 3;
		}
		return hash;
	}

	// Try to solve the puzzle, starting at configuration b.
	public boolean tryPouring(JugContents jugsObject) {
		debugPrint(jugsObject.toString());
		if (jugsObject.jugs[0] == desiredAmt
				|| jugsObject.jugs[1] == desiredAmt
				|| jugsObject.jugs[2] == desiredAmt) {
			return true;
		}

		if (hs.contains(jugsObject)) {
			return false;
		}

		hs.add(jugsObject);

		// ***** You add some code here.
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {

				if (i != j && tryPouring(pour(jugsObject, i, j))) {
					System.out
							.println("Pouring from jug " + i + " to jug " + j);
					hs.add(pour(jugsObject, i, j));
					return true;
				}
			}
		}
		return false;
	}

	// Return the result of pouring as much as possible from jug from to jug to.
	public JugContents pour(JugContents current, int from, int to) {
		JugContents afterPour = new JugContents(current);
		int amtToCanGet = capacity[to] - current.jugs[to];
		int amtFromCanSupply = current.jugs[from];
		int amtPoured = min(amtToCanGet, amtFromCanSupply);
		debugPrint("Pouring " + amtPoured + " from jug " + from + " to jug "
				+ to);
		afterPour.jugs[from] -= amtPoured;
		afterPour.jugs[to] += amtPoured;
		return afterPour;
	}

	static int min(int x, int y) {
		if (x < y) {
			return x;
		} else {
			return y;
		}
	}

	private static boolean DEBUGGING = true;

	private static void debugPrint(String s) {
		if (DEBUGGING) {
			System.out.println(s);
		}
	}

}